<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>跨域解决方案</title>
      <link href="/2020/04/25/allow-origin/"/>
      <url>/2020/04/25/allow-origin/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>跨域是浏览器端的同源策略，浏览器只允许请求当前域，例如 前端为localhost:80，只能请求localhost:80域，以下不同都会引起跨域问题：<br>  1.请求协议http,https的不同<br>  2.域ip的不同<br>  3.端口port的不同<br><img src="/my-blog/medias/blog-img/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="同源策略"></p><h2 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h2><h3 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h3><p>  跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。<br>  Cross-Origin Resource Sharing跨域资源共享,应该算是现在比较推荐的跨域处理方案.不仅适用于各种Method,而且更加方便和简单<br>  目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><h4 id="CORS跨域请求的简单请求和非简单请求"><a href="#CORS跨域请求的简单请求和非简单请求" class="headerlink" title="CORS跨域请求的简单请求和非简单请求"></a>CORS跨域请求的简单请求和非简单请求</h4><p>简单请求：<br>  1): 请求方式只能是：head，get，post<br>  2): 请求头允许的字段：Accept，Accept-Language，Content-Language，Last-Event-ID<br>  Content-Type：<br>    1.application/x-www-form-urlencoded、<br>    2.multipart/form-data、<br>    3.text/plain</p><p>复杂请求:<br>  最常见的情况，当我们使用put和delete请求时，浏览器会先发送option（预检）请求。<br>  与简单请求不同的是，option请求多了2个字段：<br>  Access-Control-Request-Method：该次请求的请求方式<br>  Access-Control-Request-Headers：该次请求的自定义请求头字段<br><img src="/my-blog/medias/blog-img/%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82.png" alt="简单请求和复杂请求"></p><h4 id="预检请求-preflight-request"><a href="#预检请求-preflight-request" class="headerlink" title="预检请求(preflight request)"></a>预检请求(preflight request)</h4><p>  在有很多情况下,当我们在js里面调用一次ajax请求时,在浏览器那边却会查询到两次请求,第一次的Request Method参数是OPTIONS,还有一次就是我们真正的请求,比如get或是post请求方式。<br>  查阅相关的资料之后发现,这是浏览器对复杂跨域请求的一种处理方式,在真正发送请求之前,会先进行一次预请求,就是我们刚刚说到的参数为OPTIONS的第一次请求,他的作用是用于试探性的服务器响应是否正确,即是否能接受真正的请求,如果在options请求之后获取到的响应是拒绝性质的,例如500等http状态,那么它就会停止第二次的真正请求的访问。<br>大致说明一下,有三种方式会导致这种现象:<br>  1:请求的方法不是GET/HEAD/POST<br>  2:POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain<br>  3:请求设置了自定义的header字段</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>  服务端设置Access-Control-Allow-Origin，响应OPTIONS即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><blockquote><p>boot环境下配置跨域</p></blockquote><pre class=" language-boot环境下配置跨域"><code class="language-boot环境下配置跨域">import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 配置跨域 */@Configurationpublic class CorsConfig implements WebMvcConfigurer {    @Override    public void addCorsMappings(CorsRegistry registry) {        registry.addMapping("/**")            .allowedOrigins("*")            .allowCredentials(true)            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")            .maxAge(3600);//预检请求信息缓存时间    }}</code></pre><blockquote><p>网关环境配置跨域</p></blockquote><pre class=" language-网关环境配置跨域"><code class="language-网关环境配置跨域">import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.reactive.CorsWebFilter;import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;/** * 网关统一配置允许跨域请求 */@Configurationpublic class MyCorsConfig {    @Bean    public CorsWebFilter getCorsWebFilter(){        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        CorsConfiguration corsConfiguration = new CorsConfiguration();        //配置跨域 允许任意请求头、请求方式、请求来源        corsConfiguration.addAllowedHeader("*");        corsConfiguration.addAllowedMethod("*");        corsConfiguration.addAllowedOrigin("*");        //允许携带cookie进行跨域        corsConfiguration.setAllowCredentials(true);        //任意路径都进行跨域配置        source.registerCorsConfiguration("/**",corsConfiguration);        return new CorsWebFilter(source);    }}</code></pre><blockquote><p>单独配置</p></blockquote><pre class=" language-单独配置"><code class="language-单独配置">@CrossOrigin(    origins = "path/to/origin",    methods = {RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS},    allowedHeaders = "*",    allowCredentials = "false",    maxAge = 86400)</code></pre><blockquote><p>Filter中配置CORS</p></blockquote><pre class=" language-Filter中配置CORS"><code class="language-Filter中配置CORS">@Override    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {        HttpServletRequest httpServletRequest = (HttpServletRequest) request;        HttpServletResponse httpServletResponse = (HttpServletResponse) response;        httpServletResponse.addHeader("Access-Control-Allow-Origin", "path/to/origin");        httpServletResponse            .addHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");        httpServletResponse.setHeader("Access-Control-Allow-Headers",            httpServletRequest.getHeader("Access-Control-Request-Headers"));        httpServletResponse.addHeader("Access-Control-Max-Age", "86400");        httpServletResponse.addHeader("Access-Control-Allow-Credentials","false");        if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) {            httpServletResponse.setStatus(HttpStatus.OK.value());            return false;        }        return super.preHandle(request, response);    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
